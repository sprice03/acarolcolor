---
title: "season_temp_color_glm"
format: html
editor: visual
---

Read in data Serena provided

```{r}

library(ggplot2)

anoleglm <- read.csv("may_data/anoleglm.csv")
```

Simple plot where we don't get model objects

```{r}

library(ggplot2)
library(scales)  # for percent_format

glmp <- ggplot(anoleglm, aes(x = hour_temperature, y = colorid, group = Season, col = Season, fill = Season)) +
    stat_smooth(
        method = "glm",
        method.args = list(family = "binomial"),
        se = TRUE
    ) +
    xlab("Temperature (°C)") +
    ylab("Percent Anoles /w Green Morph") +
    scale_y_continuous(
        labels = percent_format(accuracy = 1),
        limits = c(0, 1),
        breaks = seq(0, 1, 0.25)
    ) +
    scale_x_continuous(breaks = seq(0, 45, 10)) +
    scale_color_manual(values = c("summer only" = "#FF6666", "summer excluded" = "#55868C")) +
    scale_fill_manual(values = c("summer only" = "#FF6666", "summer excluded" = "#55868C")) +
    theme(legend.position = "none")

glmp
```

More advanced plot where we save the model objects and plot those directly to look at diagnostics and model summaries

```{r}

library(ggplot2)
library(scales)    
library(dplyr)

# make cols factors
anoleglm <- anoleglm %>%
  mutate(
    color = factor(color, levels = c("brown", "green")),
    Season = factor(Season)  # ensure Season is a factor, with levels matching below
  )


# fit two separate GLMs (one per Season) predicting color ~ hour_temperature.
model_list <- list(
  "summer only" = glm(
    formula = color ~ hour_temperature,
    data    = filter(anoleglm, Season == "summer only"),
    family  = binomial
  ),
  "summer excluded" = glm(
    formula = color ~ hour_temperature,
    data    = filter(anoleglm, Season == "summer excluded"),
    family  = binomial
  )
)

# build a grid of hour_temperature values for each Season.
#    We will predict from the minimum observed to the maximum observed within each Season.
newdata_list <- lapply(names(model_list), function(seas) {
  # Subset the original data for this season, just to find the temperature range.
  df_sub <- filter(anoleglm, Season == seas)
  
  if (nrow(df_sub) == 0) {
    stop(paste0("No rows in `anoleglm` where Season == '", seas, "'."))
  }
  
  temp_seq <- seq(
    from = min(df_sub$hour_temperature, na.rm = TRUE),
    to   = max(df_sub$hour_temperature, na.rm = TRUE),
    length.out = 100
  )
  
  data.frame(
    Season           = factor(seas, levels = expected_seasons),
    hour_temperature = temp_seq
  )
})

newdata <- bind_rows(newdata_list)

# for each Season‐specific model, predict on the logit scale (type = "link"),
#    extract the standard error, then back‐transform to get:
#      • fit   = plogis(link_fit)
#      • lower = plogis(link_fit − 1.96 * se_fit)
#      • upper = plogis(link_fit + 1.96 * se_fit)
# gpt helped me with this code
pred_list <- lapply(names(model_list), function(seas) {
  mod   <- model_list[[seas]]
  df_nd <- filter(newdata, Season == seas)
  
  if (nrow(df_nd) == 0) {
    stop(paste0("`newdata` has no rows for Season == '", seas, "'."))
  }
  
  # 5a. Predict on the link scale with SE
  pr <- predict(mod,
                newdata = df_nd,
                type    = "link",
                se.fit  = TRUE)
  
  # pr$fit  is a numeric vector (length = nrow(df_nd)) of log‐odds (η̂)
  # pr$se.fit is the standard error of the log‐odds (length = nrow(df_nd))
  link_fit <- pr$fit
  se_fit   <- pr$se.fit
  
  # 5b. Build a small data.frame of back‐transformed results
  preds <- data.frame(
    fit   = plogis(link_fit),
    lower = plogis(link_fit - 1.96 * se_fit),
    upper = plogis(link_fit + 1.96 * se_fit)
  )
  
  # 5c. Combine the original newdata subset with its predictions
  bind_cols(df_nd, preds)
})

# combine all seasons’ predictions into a single df
pred_df <- bind_rows(pred_list)

# plot the predicted probability of "green" vs. hour_temperature,
ggplot(pred_df,
       aes(x = hour_temperature,
           y = fit,
           color = Season,
           fill  = Season)) +
  # the ribbon uses `lower` and `upper` for ymin/ymax
  geom_ribbon(aes(ymin = lower, ymax = upper),
              alpha = 0.2,
              color = NA) +
  # the predicted‐probability curve
  geom_line(size = 1) +
  xlab("Temperature (°C)") +
  ylab("Predicted Probability of “Green”") +
  scale_y_continuous(
    labels = percent_format(accuracy = 1),
    limits = c(0, 1),
    breaks = seq(0, 1, 0.25)
  ) +
  scale_x_continuous(breaks = seq(0, 45, 10)) +
  scale_color_manual(values = c(
    "summer only"     = "#FF6666",
    "summer excluded" = "#55868C"
  )) +
  scale_fill_manual(values = c(
    "summer only"     = "#FF6666",
    "summer excluded" = "#55868C"
  )) +
  theme_minimal() +
  theme(legend.position = "none")

```

Look at diagnostics and summary stats to liking

```{r}

summary(model_list[["summer only"]])
```
